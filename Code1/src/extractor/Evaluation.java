package extractor;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FileReader;import java.io.InputStreamReader;import java.io.PrintStream;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;import utils.ConfusionMatrix;import utils.FileFinder;public class Evaluation {	public int totalDoc;	public int totalWord = 0;	public int correctTopic = 0;	public int incorrectTopic = 0;	public double microPrecision;	public double microRecall;	public double microF1;	public double macroPrecision;	public double macroRecall;	public double macroF1;	public String txtPath;	public String splitmark = "\t";	HashMap<String,ConfusionMatrix[]> cmps = new HashMap<String,ConfusionMatrix[]>();	static HashMap<String,Integer> classId = new HashMap<String,Integer>();		public void readClass(String path){		File file = new File(path);		BufferedReader reader = null;		try {			reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));  			String buf=null;			int count= 0 ;			while((buf=reader.readLine())!=null){				if(buf.length()>1){					classId.put(buf.replaceAll("\\s+", ""), count);					count++;				}			}		} catch (Exception e) {			// TODO Auto-generated catch block			e.printStackTrace();		}	}		public Evaluation(String string) throws Exception {		readClass("E:/ClefeHealth/Data/training-classes.txt");//replace the path here		txtPath = string;		FileFinder ff = new FileFinder();		ArrayList<File> files = ff.GetAllFiles(txtPath, true);				//Total number of documents		totalDoc = files.size();		for (int i = 0; i < files.size(); i++){			File f = files.get(i);			execute(f,i);		}		Averaged();	}		private void execute(File f, int i) throws Exception {		BufferedReader br = new BufferedReader(new FileReader(f));		String line = null;		System.out.println("***********" + f.getName());		while ((line = br.readLine()) != null) {			String[] split = line.split(splitmark);			if (split.length < 2) continue;			totalWord++;					String annotated = split[split.length-2];			String predicted = split[split.length-1];			if(cmps.containsKey(annotated)){				cmps.get(annotated)[i].annotatedSet += 1;			} else{				ConfusionMatrix[] cm = new ConfusionMatrix[totalDoc + 1];				for(int j = 0; j < cm.length; j++){					cm[j] = new ConfusionMatrix();				}				cm[i].annotatedSet = 1;				cmps.put(annotated, cm);			}			if(cmps.containsKey(predicted)){				cmps.get(predicted)[i].predictionSet += 1;			} else{				ConfusionMatrix[] cm = new ConfusionMatrix[totalDoc + 1];				for(int j = 0; j < cm.length; j++){					cm[j] = new ConfusionMatrix();				}				cm[i].predictionSet = 1;				cmps.put(predicted, cm);			}						if(annotated.equals(predicted)) {				cmps.get(annotated)[i].TP += 1;				correctTopic += 1;			}			else {				cmps.get(annotated)[i].FP += 1;				incorrectTopic += 1;			}						}		br.close();					}	private void Averaged() {				//->first, then vertical		int sumTP = 0;		int sumTPFP = 0;		int sumTPFN = 0;				double sumP = 0;		double sumR = 0;				Iterator<Entry<String, ConfusionMatrix[]>> iter1 = cmps.entrySet().iterator();		while (iter1.hasNext()) {		    Entry<String, ConfusionMatrix[]> entry1 = iter1.next();		    //for every label, vertical		    ConfusionMatrix[] cms = entry1.getValue();		    String label = entry1.getKey();		    double sump = 0.0;		    double sumr = 0.0;		    		    double sumtp = 0.0;		    double sumtpfn = 0.0;		    double sumtpfp = 0.0;		    		    int total = 0;		    for (int i = 0; i < cms.length - 1;i++){		    	if(cms[i].annotatedSet > 0 || cms[i].predictionSet > 0){		    		total ++;		    		cms[i].precision = cms[i].TP * 1.0 / cms[i].predictionSet;			    	cms[i].recall = cms[i].TP * 1.0 / cms[i].annotatedSet;			    				    	if(cms[i].precision >0) sump += cms[i].precision;			    	if(cms[i].recall > 0) sumr += cms[i].recall;			    				    	sumtp += cms[i].TP;			    	sumtpfp += cms[i].predictionSet;			    	sumtpfn += cms[i].annotatedSet;			    				    	cms[totalDoc].annotatedSet += cms[i].annotatedSet;			    	cms[totalDoc].predictionSet += cms[i].predictionSet;			    				    	if(!entry1.getKey().equals("NA")&&classId.containsKey(label)){			    		sumTP+=sumtp;			    		sumTPFP+=sumtpfp;			    		sumTPFN+=sumtpfn;			    		sumP+=sump;			    		sumR+=sumr;			    	}		    	}		    }		    cms[totalDoc].TP = (int) sumtp;		    double MacroP = sump / total;		    double MacroR = sumr / total;		    double MacroF = 2.0 * (MacroP * MacroR)/ (MacroP + MacroR);		    		    cms[totalDoc].MacroP = MacroP;		    cms[totalDoc].MacroR = MacroR;		    cms[totalDoc].MacroF = MacroF;		    		    double MicroP = sumtp / sumtpfp;		    double MicroR = sumtp / sumtpfn;		    double MicroF = 2.0 * (MicroP * MicroR)/ (MicroP + MicroR);		    		    cms[totalDoc].MicroP = MicroP;		    cms[totalDoc].MicroR = MicroR;		    cms[totalDoc].MicroF = MicroF;		 }				microPrecision = sumTP*1.0/ sumTPFP;		microRecall = sumTP*1.0/ sumTPFN; 		microF1 = 2 * microPrecision * microRecall / (microPrecision+microRecall);				macroPrecision = sumP *1.0/ 35;		macroRecall = sumR / 35;		macroF1 = 2 * macroPrecision * macroRecall / (macroRecall + macroPrecision);	}	public void printResult(String outputPath) throws Exception {		String string = outputPath;		@SuppressWarnings("resource")		PrintStream	ps = new PrintStream(new FileOutputStream(string));		ps.println("Total number of documents: " + totalDoc);		ps.println("Total number of words: " + totalWord);		ps.println("Correct topic: " + correctTopic);		ps.println("Incorrect topic: " + incorrectTopic);		ps.println();		ps.println("macroPrecision\tmacroRecall\tmacroF1\tmicroPrecision\tmicroRecall\tmicroF1\n");		ps.printf("%.2f%%\t", macroPrecision * 100);		ps.printf("%.2f%%\t", macroRecall * 100);		ps.printf("%.2f%%\t", macroF1 * 100);		ps.printf("%.2f%%\t", microPrecision * 100);		ps.printf("%.2f%%\t", microRecall * 100);		ps.printf("%.2f%%\t",microF1 * 100);		ps.printf("overall\n");		ps.println();		Iterator<Entry<String, ConfusionMatrix[]>> iter = cmps.entrySet().iterator();		while (iter.hasNext()) {		    Entry<String, ConfusionMatrix[]> entry = iter.next();		    ConfusionMatrix[] cm = entry.getValue();		    String label = entry.getKey();		    //TODO: for form filling		    if(classId.containsKey(label)){		    	ps.printf("%.2f%%\t%.2f%%\t%.2f%%\t", cmps.get(label)[totalDoc].MacroP * 100 , cmps.get(label)[totalDoc].MacroR * 100, cmps.get(label)[totalDoc].MacroF * 100);		    	ps.printf("%.2f%%\t%.2f%%\t%.2f%%\t", cmps.get(label)[totalDoc].MicroP * 100 , cmps.get(label)[totalDoc].MicroR * 100, cmps.get(label)[totalDoc].MicroF * 100);		    	ps.println(entry.getKey() + "(" + cm[totalDoc].annotatedSet + " annotated;"+cm[totalDoc].predictionSet+" predicted;" +  cm[totalDoc].TP + " correct):");		    }		}	}}